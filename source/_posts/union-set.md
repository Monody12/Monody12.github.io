title: 并查集
author: Monody12
tags:
  - union set
categories:
  - algorithm
date: 2021-05-04 21:12:00
---
title: 并查集
author: Monody12
tags:
  - union set
categories:
  - algorithm
date: 2021-05-04 21:12:00
---
目录
1. [应用场景](#应用场景)
2. [实现方式](#实现方式)
3. [例题实战](#例题实战)

## 应用场景
在什么情况下需要使用并查集？
通常情况下在进行集合合并操作时，我们会将一个集合A中的元素全部导入另一个集合B。那么怎样导入呢，是把集合A的元素一个一个的拿出来依次加入集合B，加入的时候使用set或者hashset。在数据量比较小的情况下，这样是行得通的。如果数据量很大，并且一堆集合需要反复合并。其中一些元素可能被来回加入取出很多次，花费很多时间。这时候并查集就派上用场了。

简而言之：大量的**集合合并**操作

## 实现方式
### 核心思想
可以把元素之间用一个线连接起来，形成一个连通块，这个连通块不就是一个集合吗？那么我们在合并两个集合的时候将这两个连通块中的任意一个元素拿出来然后用线连接起来，这样两个连通块就变成了一个连通块，就实现了集合合并。

而并查集实现以上介绍的方法非常巧妙。它使用了父元素的方式来记录当前元素是属于哪个元素的集合。即p[x]表示为x的父元素。而如果p[x]==x则表示这个集合的根（集合的根可以想象为这个集合的中心）就是x。合并集合就是将这个集合的根指向另一个集合的元素（通常写的时候直接指向根了）。

### 主要操作
摘自[百度百科](https://baike.baidu.com/item/%E5%B9%B6%E6%9F%A5%E9%9B%86/9388442?fr=aladdin#1)  
#### 初始化  
把每个点所在集合初始化为其自身。  `p[i] = i;`
通常来说，这个步骤在每次使用该数据结构时只需要执行一次，无论何种实现方式，时间复杂度均为O(N)。  
#### 查找  
查找元素x所在的集合，即根节点。 编写find(int x)函数 (到后面再介绍)
#### 合并  
将两个元素所在的集合合并为一个集合。  `p[find(x)] = find(y);`  
通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现。

### 优化
在查找一个集合的根时，如果这个集合中有大量的元素，而查询的元素又是距离根根元素最远的，那么经常查询，势必又会消耗大量的时间。那么有办法能让我们的元素尽可能的离根元素近吗？当然能！

#### 路径压缩
使用路径压缩优化，可以在查询当前元素的根元素的时候直接把路径上的元素的父元素直接**指向根元素**，这样以来，并查集就呈现出了中心趋势，所有除根元素以外的元素都直接指向根元素了。
```c++
	int find(int x) {//查找元素x所属集合的根节点
		if (p[x] != x)
			p[x] = find(p[x]);//查找父亲结点，顺带 路径压缩 优化
		return p[x];
}

```

## 例题实战

 
[Rumor](https://codeforces.com/problemset/problem/893/C)  

题意：在一个游戏中，你有一些朋友，你的任务是将你的信息传递给所有朋友。你传递信息给朋友需要花费一定的金钱，但是朋友收到你的信息后，会告诉Ta的其他朋友（此时你不用花费金钱）。你应该选择告诉哪些朋友，使得你能够完成任务，同时花费的金钱最少。

### 输入
第1行：给定你的朋友数量n和朋友之间的关系数量m。
第2行：给定你告诉第i个朋友需要花费的金钱ci 。
第3-3+m行 每行两个数a,b 表示这两个人是朋友关系。

### 输出
完成任务最少需要花费金钱。


### 用例
输入  
5 2  
2 5 3 4 8  
1 4  
4 5  
输出  
10

### 解释
1，4，5之间有直间或间接的朋友关系，直接告诉1花费最少。3，4需要你单独告诉。因此最少花费为10 。

### 思路
通过样例我们知道：在一个朋友圈中（连通块），只要选出一个花费最少的朋友，告诉就行。在不断地处理朋友圈关系（梳理朋友关系）时，不正是集合的合并吗。因此使用并查集找出集合个数，在分别在每个集合中选出一个最小的元素加起来就行了。

### 确定集合个数
在复杂的集合关系中如何确定集合个数，只要知道有几个根元素即可。那处理完所有集合元素关系时，不一定每个集合元素的父元素都是根元素，所以我们还需要对每个元素进行一次根元素查询操作，然其父元素为根元素。



```c++
#include <cstdio>
#include <vector>
#include <climits>
#include <algorithm>

#define input freopen("//home//user//桌面//a.txt","r",stdin)
using namespace std;

int p[100005], a[100005];  //并查集 p[x]表示x的父元素
int find(int x) {
    if (p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}

int main() {
    //input;
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", a + i);
        p[i] = i;  //初始化并查集
    }
    int x, y, px, py;
    for (int i = 0; i < m; ++i) {
        scanf("%d%d", &x, &y);
        p[find(x)] = find(y);  //将x集合合并到y集合中
    }
    vector<int> set[100005];
    for (int i = 1; i <= n; ++i) {  //根据并查集划分出集合
        p[i]= find(i);  //重要！ 将并查集父元素指向集合根部 这样才能找出一个连通块内的全部元素
        set[p[i]].push_back(i);
    }
    long long int sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (set[i].empty())
            continue;
        int min_cost = INT_MAX;
        for (int t:set[i])
            min_cost = min(min_cost, a[t]);
        sum += min_cost;
    }
    printf("%lld", sum);
    return 0;
}

```
